#' @title Paired factor analysis model
#' @description ...
#' @param X [N, J] matrix of observed data
#' @param K [int] number of factors
#' @param F [K, J] initial factor matrix
#' @param P [K, K] initial factor frequency matrix: the lower triangle is pair frequencies,
#' the diagonal is single factor frequencies.
#' @param q [C, 1] / [int] defines initial vector of possible membership loadings, a discrete set
#' @param priors [double, double] priors for edge weights and grid weights
#' @param control \{tol = 1E-5, maxiter = 10000, logfile = NULL, n_cpu = 1\} list of runtime variables
#' @return A list with elements below:
#' \item{F}{...}
#' \item{L}{...}
#' \item{P}{...}
#' \item{loglik}{...}
#' \item{loglik_diff}{...}
#' \item{niter}{...}
#' \item{status}{...}
#' @details
#' \itemize{
#' \item q: When q is set to integer, q vector will be generated by seq(0, 100, by = max(as.integer(100 / q), 1)) / 100
#'}
#' @author Gao Wang and Kushal K. Dey
#' @references ...
#' @examples
#' ## The example data set can be installed via
#' ## devtools::install_github("kkdey/singleCellRNASeqMouseDeng2014")
#' library(singleCellRNASeqMouseDeng2014)
#' meta_data <- pData(Deng2014MouseESC)
#' dat = exprs(Deng2014MouseESC)
#' K = 6
#' dat = t(limma::voom(dat)$E)
#' dr_dat = pfar::dr_pca(dat)
#' init_val = pfar::init_weight_princurve(dr_dat, pfar::init_factor_block(dr_dat, K)$factors)
#' control = list(logfile = 'example_data.pfa', n_cpu = 8)
#' res = pfar::pfa(dr_dat, F = init_val$factors, P = init_val$weights, control = control)
#' print(res)
#' @useDynLib pfar
#' @export

pfa <- function(X, K = NULL, F = NULL, P = NULL, q = NULL, priors = NULL,
                control = NULL) {
  ## Initialize data
  if (is.null(F) && is.null(K)) {
    stop("[ERROR] Please provide either K or F!")
  }
  if (is.null(F)) {
    # Initialize F with random K factors
    # FIXME: Have to find a smarter initilization of F
    F <- X[sample(nrow(X), size = K, replace = FALSE),]
  } else {
    K <- nrow(F)
  }
  if (is.null(P)) {
    # Initialize P uniformly
    P <- matrix(0, K, K)
    P[lower.tri(P)] <- 2 / ((K + 1) * K)
    diag(P) <- 2 / ((K + 1) * K)
  }
  if (is.null(q)) {
    # Initialze q to be 0/100, 1/100, 2/100, ..., 1
    q <- seq(0, 100) / 100
  }
  if (is.integer(q)) {
    q <- seq(0, 100, by = max(as.integer(100 / q), 1)) / 100
  }
  if (is.null(priors)) {
    priors <- c(2 / ((K + 1) * K), 1)
  }
  tol <- as.double(control$tol)
  if (length(tol) == 0 || tol <= 0) {
    tol <- 1E-4
  }
  maxiter <- as.integer(control$maxiter)
  if (length(maxiter) == 0 || maxiter <= 0) {
    maxiter <- 10000
  }
  n_cpu <- as.integer(control$n_cpu)
  if (length(n_cpu) == 0 || n_cpu <= 0) {
    n_cpu <- 1
  }
  logfile <- control$logfile
  if (is.null(logfile)) {
    f1 <- n_f1 <- f2 <- n_f2 <- 0
  } else {
    f1 <- charToRaw(paste(logfile, "updates.log", sep = "."))
    f2 <- charToRaw(paste(logfile, "debug.log", sep = "."))
    n_f1 <- length(f1)
    n_f2 <- length(f2)
  }
  ## sanity check
  stopifnot(nrow(F) == K)
  stopifnot(ncol(X) == ncol(F))
  stopifnot(nrow(F) == nrow(P))
  stopifnot(nrow(P) == ncol(P))
  stopifnot(length(priors) == 2)
  ## factor analysis
  loglik <- rep(-999, maxiter)
  niter <- 0
  L <- matrix(0, nrow(X), nrow(F))
  alpha <- matrix(0, nrow(F), nrow(F))
  beta <- rep(0, length(q))
  status <- 0
  res <- .C("pfa_em",
            as.double(as.vector(X)),
            F = as.double(as.vector(F)),
            P = as.double(as.vector(P)),
            as.double(as.vector(q)),
            as.integer(nrow(X)),
            as.integer(ncol(X)),
            as.integer(nrow(F)),
            as.integer(length(q)),
            as.double(priors[1]),
            as.double(priors[2]),
            as.double(tol),
            as.integer(maxiter),
            niter = as.integer(niter),
            loglik = as.double(as.vector(loglik)),
            L = as.double(as.vector(L)),
            alpha = as.double(as.vector(alpha)),
            beta = as.double(as.vector(beta)),
            status = as.integer(status),
            as.integer(as.vector(f1)),
            as.integer(n_f1),
            as.integer(as.vector(f2)),
            as.integer(n_f2),
            as.integer(n_cpu),
            PACKAGE = "pfar")
  ## Process output
  Fout <- matrix(res$F, nrow(F), ncol(F))
  Lout <- matrix(res$L, nrow(L), ncol(L))
  alphaout <- matrix(res$alpha, nrow(alpha), ncol(alpha))
  Pout <- matrix(res$P, nrow(P), ncol(P))
  loglik <- res$loglik[1:res$niter]
  return(list(F_init = F, F = Fout, L = Lout, P = Pout,
              alpha = alphaout, beta = res$beta,
              loglik = loglik, loglik_diff = diff(loglik),
              niter = res$niter, status = res$status))
}

#' @title Get model likelihood for PFA 
#' @description This is a diagnostic function that computes likelihood given simulation parameters
#' @param D [N, J] matrix of simulated data
#' @param F [K, J] true factor matrix
#' @param E [K * (K - 1) / 2, 3] sample size (column 3) between each factor pair (indexed in column 1 and 2)
#' @param Svec [J, 1] vector of simulated standard deviation for features
#' @param pi_q [C, 1] vector of weights for simulated membership loadings
#' @details
#' @author Gao Wang and Kushal K. Dey
#' @references ...
#' @examples
#' @export

#function to find the log of the sum of exp(lx).
lsum <- function(lx){
  m <- max(lx)
  m + log(sum(exp(lx-m)))
}

get_model_lik <- function(D, FCT, E, Svec, pi_q = NULL, log_scale = TRUE, reversed = FALSE) {
  K <- nrow(FCT)
  key <- t(combn(K, 2))
  key <- cbind(key, seq(1:nrow(key)))
  sumN <- sum(E[,3])
  # pi_k and pi_q are independent in the model
  ncol_pi_mat <- max(E[,3])
  pi_mat <- matrix(0, nrow(key), ncol_pi_mat)
  pi_k <- vector()
  for (k in 1:(K - 1)) {
    for (l in (k+1):K) {
      keyval <- key[which(key[,1] == k & key[,2] == l), 3]
      num_q <- E[which(E[,1] == k & E[,2] == l), 3]
      if (length(num_q) == 0)
        next
      pi_k[keyval] <- num_q / sumN
      if (is.null(pi_q)) {
        pi_qk <- rep(1 / num_q, num_q)
      } else {
        stopifnot(length(pi_q != num_q))
        pi_qk <- pi_q
      }
      for (q in 1:num_q) {
        pi_mat[keyval,q] <- pi_k[keyval] * pi_qk[q]
      }
    }
  }
  lik_mat <- array(0, c(nrow(D), nrow(key), ncol_pi_mat))
  loglik <- 0

  for (m in 1:nrow(D)) {
    for (k in 1:(K - 1)) {
      for (l in (k+1):K) {
        keyval <- key[which(key[,1] == k & key[,2] == l), 3]
        num_q <- E[which(E[,1] == k & E[,2] == l), 3]
        if (length(num_q) == 0)
          next
        Qvec <- seq(0, 1, length.out = num_q)
        for (q in 1:num_q) {
          if (reversed) {
            lik_mat[m, keyval, q] <- exp(log(pi_mat[keyval, q]) + sum(dnorm(D[m,], (1 - Qvec[q]) * FCT[k,] + Qvec[q] * FCT[l,], Svec, log = TRUE)))
          } else {
            lik_mat[m, keyval, q] <- exp(log(pi_mat[keyval, q]) + sum(dnorm(D[m,], Qvec[q] * FCT[k,] + (1 - Qvec[q]) * FCT[l,], Svec, log = TRUE)))
          }
        }
      }
    }
    loglik <- loglik + log(sum(lik_mat[m,,]))
  }
  if (log_scale == FALSE) {
    return(exp(loglik))
  } else {
    return(loglik)
  }
}
